function pdd = p_dyn(eta, pdot, T)
    % p_dyn computes the acceleration of the drone in the inertial frame 
    % based on its orientation (eta), velocity (pdot), and thrust (T).
    % 
    % Inputs:
    %   eta  - [roll; pitch; yaw] angles (in radians) defining the drone's orientation
    %   pdot - [xd; yd; zd] velocity components in the inertial frame (m/s)
    %   T    - Thrust force generated by the propellers (N)
    %
    % Outputs:
    %   pdd  - [x_dd; y_dd; z_dd] acceleration components in the inertial frame (m/s^2)
    %
    % Assumptions:
    %   - The drone's mass (m) and gravitational acceleration (g) are known constants.
    %   - The equations are based on the Newton-Euler dynamics of a quadrotor.

    % Extract roll, pitch, and yaw angles from the vector eta
    roll = eta(1);   % Roll angle (phi)
    pitch = eta(2);  % Pitch angle (theta)
    yaw = eta(3);    % Yaw angle (psi)
    
    % Extract velocity components in the inertial frame
    xd = pdot(1);    % Velocity in the x-direction
    yd = pdot(2);    % Velocity in the y-direction
    zd = pdot(3);    % Velocity in the z-direction
    
    % Trigonometric shorthand for efficiency
    c_phi = cos(roll);    % Cosine of roll angle
    s_phi = sin(roll);    % Sine of roll angle
    c_theta = cos(pitch); % Cosine of pitch angle
    s_theta = sin(pitch); % Sine of pitch angle
    c_psi = cos(yaw);     % Cosine of yaw angle
    s_psi = sin(yaw);     % Sine of yaw angle
    
    % Dynamic equations of motion:
    % Acceleration components in the inertial frame due to thrust and gravity
    x_dd = (T/m) * (c_theta * c_psi * xd + ...
                    (s_phi * s_theta * c_psi - c_phi * s_psi) * yd + ...
                    (c_phi * s_theta * c_psi + s_phi * s_psi) * zd);
                
    y_dd = (T/m) * (c_theta * s_psi * xd + ...
                    (s_phi * s_theta * s_psi + c_phi * c_psi) * yd + ...
                    (c_phi * s_theta * s_psi - s_phi * c_psi) * zd);
                
    z_dd = -g + (T/m) * (-s_theta * xd + ...
                         s_phi * c_theta * yd + ...
                         c_phi * c_theta * zd);
    
    % Combine accelerations into a vector
    pdd = [x_dd; y_dd; z_dd];
end
